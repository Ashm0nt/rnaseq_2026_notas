# Modelos estadísticos

Para entender modelos estadísticos podemos usar palabras, ecuaciones, gráficos, etc. Para entender un modelo estadístico es importante entender los datos que se están analizando, las preguntas que se quieren responder y las suposiciones que se están haciendo sobre los datos.

## Regresión lineal

La regresión lineal es un modelo estadístico que se utiliza para analizar la relación entre una variable dependiente y una o más variables independientes. El modelo asume que la relación entre las variables es lineal, lo que significa que la variable dependiente puede ser expresada como una combinación lineal de las variables independientes.

- β0 Punto en el eje y cuando X es igual a 0, es decir, el valor esperado de Y cuando X es igual a 0.
- β1 is the average change in our outcome Y for a one unit increase in our explanatory variable  X.

```{r}
# Ejemplo de regresión lineal
mat <- with(trees, model.matrix(log(Volume) ~ log(Height) + log(Girth)))
mat

summary(lm(log(Volume) ~ log(Height) + log(Girth), data = trees))

# Residuals:
#       Min        1Q    Median        3Q       Max 
# -0.168561 -0.048488  0.002431  0.063637  0.129223 

# Coefficients:
#             Estimate Std. Error t value Pr(>|t|)    
# (Intercept) -6.63162    0.79979  -8.292 5.06e-09 ***
# log(Height)  1.11712    0.20444   5.464 7.81e-06 ***
# log(Girth)   1.98265    0.07501  26.432  < 2e-16 ***
```

- *t* es el valor de la estadística t, que se calcula como el cociente entre el coeficiente estimado y su error estándar. Este valor se utiliza para evaluar la significancia estadística del coeficiente, es decir, para determinar si el coeficiente es significativamente diferente de cero. Si tenemos un tamaño de muestra grande se asimila a una normal y se puede usar la distribución normal para calcular el valor p asociado a la estadística t. Si el valor p es menor que un umbral de significancia (por ejemplo, 0.05), se rechaza la hipótesis nula de que el coeficiente es igual a cero, lo que sugiere que hay una relación significativa entre la variable independiente y la variable dependiente.

## ExploreModelMatrix

ExploreModelMatrix es una función que se utiliza para explorar la matriz de diseño de un modelo estadístico. La matriz de diseño es una representación matricial de las variables independientes en un modelo estadístico, donde cada fila representa una observación y cada columna representa una variable independiente. ExploreModelMatrix permite visualizar la estructura de la matriz de diseño, lo que puede ayudar a identificar problemas como la multicolinealidad entre las variables independientes o la presencia de valores faltantes. Esta función es útil para comprender mejor el modelo estadístico que se está utilizando y para asegurarse de que los datos se están analizando de manera adecuada.

```{r}
## Datos de ejemplo
(sampleData <- data.frame(
    genotype = rep(c("A", "B"), each = 4),
    treatment = rep(c("ctrl", "trt"), 4)
))

## Generemos las imágenes usando ExploreModelMatrix
vd <- ExploreModelMatrix::VisualizeDesign(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment,
    textSizeFitted = 4
)

## Veamos las imágenes
cowplot::plot_grid(plotlist = vd$plotlist)
```

```{r}
library(ExploreModelMatrix)
app <- ExploreModelMatrix(
    sampleData = sampleData,
    designFormula = ~ genotype + treatment
)
if (interactive()) shiny::runApp(app)
```


### Ejericio


```{r}
library(recount3)
human_projects <- available_projects()

rse_gene_SRP045638 <- create_rse(
    subset(
        human_projects,
        project == "SRP045638" & project_type == "data_sources"
    )
)
assay(rse_gene_SRP045638, "counts") <- compute_read_counts(rse_gene_SRP045638)
## ----describe_issue-------------------------------------------
rse_gene_SRP045638$sra.sample_attributes[1:3]


## ----solve_issue----------------------------------------------
## Extra column
rse_gene_SRP045638$sra.sample_attributes <- gsub("dev_stage;;Fetal\\|", "", rse_gene_SRP045638$sra.sample_attributes)
rse_gene_SRP045638$sra.sample_attributes[1:3]


## ----attributes-----------------------------------------------
rse_gene_SRP045638 <- expand_sra_attributes(rse_gene_SRP045638)

colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute", colnames(colData(rse_gene_SRP045638)))
]


## ----re_cast--------------------------------------------------
## Pasar de character a numeric o factor
rse_gene_SRP045638$sra_attribute.age <- as.numeric(rse_gene_SRP045638$sra_attribute.age)
rse_gene_SRP045638$sra_attribute.disease <- factor(tolower(rse_gene_SRP045638$sra_attribute.disease))
rse_gene_SRP045638$sra_attribute.RIN <- as.numeric(rse_gene_SRP045638$sra_attribute.RIN)
rse_gene_SRP045638$sra_attribute.sex <- factor(rse_gene_SRP045638$sra_attribute.sex)

## Resumen de las variables de interés
summary(as.data.frame(colData(rse_gene_SRP045638)[
    ,
    grepl("^sra_attribute.[age|disease|RIN|sex]", colnames(colData(rse_gene_SRP045638)))
]))

```

Hay que tener un control de calidad con las muestras y los genes antes de hacer cualquier análisis estadístico. 
```{r}
## ----new_variables--------------------------------------------
## Encontraremos diferencias entre muestra prenatalas vs postnatales
rse_gene_SRP045638$prenatal <- factor(ifelse(rse_gene_SRP045638$sra_attribute.age < 0, "prenatal", "postnatal"))
table(rse_gene_SRP045638$prenatal)

## http://rna.recount.bio/docs/quality-check-fields.html
rse_gene_SRP045638$assigned_gene_prop <- rse_gene_SRP045638$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP045638$recount_qc.gene_fc_count_all.total
summary(rse_gene_SRP045638$assigned_gene_prop)
with(colData(rse_gene_SRP045638), plot(assigned_gene_prop, sra_attribute.RIN))

## Hm... veamos si hay una diferencia entre los grupos
with(colData(rse_gene_SRP045638), tapply(assigned_gene_prop, prenatal, summary))


## ----filter_rse-----------------------------------------------
## Guardemos nuestro objeto entero por si luego cambiamos de opinión
rse_gene_SRP045638_unfiltered <- rse_gene_SRP045638

## Eliminemos a muestras malas
hist(rse_gene_SRP045638$assigned_gene_prop)
table(rse_gene_SRP045638$assigned_gene_prop < 0.3)
rse_gene_SRP045638 <- rse_gene_SRP045638[, rse_gene_SRP045638$assigned_gene_prop > 0.3]

## Calculemos los niveles medios de expresión de los genes en nuestras
## muestras.
## Ojo: en un análisis real probablemente haríamos esto con los RPKMs o CPMs
## en vez de las cuentas.
## En realidad usariamos:
# edgeR::filterByExpr() https://bioconductor.org/packages/edgeR/ https://rdrr.io/bioc/edgeR/man/filterByExpr.html
# genefilter::genefilter() https://bioconductor.org/packages/genefilter/ https://rdrr.io/bioc/genefilter/man/genefilter.html
# jaffelab::expression_cutoff() http://research.libd.org/jaffelab/reference/expression_cutoff.html
#
gene_means <- rowMeans(assay(rse_gene_SRP045638, "counts"))
summary(gene_means)

## Eliminamos genes
rse_gene_SRP045638 <- rse_gene_SRP045638[gene_means > 0.1, ]

## Dimensiones finales
dim(rse_gene_SRP045638)

## Porcentaje de genes que retuvimos
round(nrow(rse_gene_SRP045638) / nrow(rse_gene_SRP045638_unfiltered) * 100, 2)

```

Luego se deben normalizar los datos para poder hacer un análisis estadístico adecuado, pero eso lo veremos en la siguiente sección.

- Problema hipotético: Composition bias.

```{r}
## ----normalize------------------------------------------------
library("edgeR") # BiocManager::install("edgeR", update = FALSE)
dge <- DGEList(
    counts = assay(rse_gene_SRP045638, "counts"),
    genes = rowData(rse_gene_SRP045638)
)
dge <- calcNormFactors(dge)


## ----explore_gene_prop_by_age---------------------------------
library("ggplot2")
ggplot(as.data.frame(colData(rse_gene_SRP045638)), aes(y = assigned_gene_prop, x = prenatal)) +
    geom_boxplot() +
    theme_bw(base_size = 20) +
    ylab("Assigned Gene Prop") +
    xlab("Age Group")

```

Modelo estadístico

```{r}
## ----statiscal_model------------------------------------------
mod <- model.matrix(~ prenatal + sra_attribute.RIN + sra_attribute.sex + assigned_gene_prop,
    data = colData(rse_gene_SRP045638)
)
colnames(mod)

## ----run_limma------------------------------------------------
library("limma")
vGene <- voom(dge, mod, plot = TRUE)

eb_results <- eBayes(lmFit(vGene))

de_results <- topTable(
    eb_results,
    coef = 2,
    number = nrow(rse_gene_SRP045638),
    sort.by = "none"
)
dim(de_results)
head(de_results)

## Genes diferencialmente expresados entre pre y post natal con FDR < 5%
table(de_results$adj.P.Val < 0.05)

```

limma es un paquete que hace análisis de expresión diferencial utilizando un modelo lineal generalizado. En lugar de utilizar una distribución de Poisson o una distribución binomial negativa para modelar las cuentas de expresión génica, limma utiliza un modelo lineal generalizado que asume que los datos siguen una distribución normal. Esto se logra mediante la transformación de los datos utilizando la función voom, que convierte las cuentas de expresión génica en log2-counts per million (logCPM) y estima la varianza de cada gen en función de su nivel de expresión. Luego, limma utiliza esta información para ajustar un modelo lineal generalizado y realizar pruebas estadísticas para identificar genes diferencialmente expresados entre grupos. Esta aproximación es especialmente útil cuando se tienen muestras con diferentes niveles de expresión génica, ya que permite modelar la heterogeneidad en la varianza de los datos y mejorar la potencia estadística del análisis de expresión diferencial.

Ahora en la parte de visualización, lo más común es hacer un gráfico de volcan, que muestra la relación entre el valor p y el log2 fold change de cada gen, lo que permite identificar fácilmente los genes que son significativamente diferencialmente expresados entre grupos. Otro grafico es el MA plot, que muestra la relación entre el log2 fold change y el nivel de expresión de cada gen, lo que permite identificar genes que son diferencialmente expresados entre grupos y que tienen un nivel de expresión alto o bajo. También se pueden hacer gráficos de barras o gráficos de violín para mostrar la distribución de los niveles de expresión de los genes diferencialmente expresados entre grupos. Y por último un heatmap para mostrar la expresión de los genes diferencialmente expresados entre grupos, lo que permite identificar patrones de expresión y agrupamientos de genes y muestras.

```{r}
# Visualicemos los resultados estadísticos
plotMA(eb_results, coef = 2)

volcanoplot(eb_results, coef = 2, highlight = 3, names = de_results$gene_name)
de_results[de_results$gene_name %in% c("ZSCAN2", "VASH2", "KIAA0922"), ]


## ----pheatmap-------------------------------------------------
## Extraer valores de los genes de interés
exprs_heatmap <- vGene$E[rank(de_results$adj.P.Val) <= 50, ]

## Creemos una tabla con información de las muestras
## y con nombres de columnas más amigables
df <- as.data.frame(colData(rse_gene_SRP045638)[, c("prenatal", "sra_attribute.RIN", "sra_attribute.sex")])
colnames(df) <- c("AgeGroup", "RIN", "Sex")

## Hagamos un heatmap
library("pheatmap")
pheatmap(
    exprs_heatmap,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = FALSE,
    annotation_col = df
)

```

También puede ser un MDS plot, que muestra la relación entre las muestras en función de su expresión génica, lo que permite identificar agrupamientos de muestras y patrones de expresión. En este caso, se puede colorear las muestras por el grupo de edad (prenatal vs postnatal) para ver si hay una separación clara entre los grupos.

```{r}
## ----plot_mds-------------------------------------------------
## Para colores
library("RColorBrewer")

## Conviertiendo los grupos de edad a colores
col.group <- df$AgeGroup
levels(col.group) <- brewer.pal(nlevels(col.group), "Set1")
col.group <- as.character(col.group)

## MDS por grupos de edad
plotMDS(vGene$E, labels = df$AgeGroup, col = col.group)

## Conviertiendo los valores de Sex a colores
col.sex <- df$Sex
levels(col.sex) <- brewer.pal(nlevels(col.sex), "Dark2")
col.sex <- as.character(col.sex)

## MDS por sexo
plotMDS(vGene$E, labels = df$Sex, col = col.sex)

```